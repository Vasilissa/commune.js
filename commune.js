// Generated by CoffeeScript 1.4.0

/*
  * Commune.js
  * Web workers lose their chains
  * 0.2.0
  * Easy, DRY, transparent worker threads for your app
  * Dan Motzenbecker
  * http://oxism.com
  * MIT License
*/


(function() {
  var Commune, communes, makeBlob, root, threadSupport;

  root = this;

  communes = {};

  makeBlob = null;

  Commune = (function() {

    function Commune(fn) {
      var fnName, fnString, lastReturnIndex, returnStatement;
      fnString = fn.toString();
      if (fnString.match(/this/)) {
        if (typeof console !== "undefined" && console !== null) {
          console.warn("Commune: Referencing `this` within a worker process will not work.\n`this` will refer to the worker itself.\nThe passed function appears to use it, but the worker will still be created.");
        }
      }
      if ((lastReturnIndex = fnString.lastIndexOf('return')) === -1) {
        throw new Error('Commune: Target function has no return statement.');
      }
      returnStatement = fnString.substr(lastReturnIndex).replace('return', '').replace(/\}$/, '').replace(';', '');
      fnString = fnString.slice(0, lastReturnIndex) + ("\nself.postMessage(" + returnStatement + ");\n}");
      fnName = fnString.match(/function\s(.+)\(/i);
      if (fnName[1] != null) {
        fnString = fnString.replace(fnName[1], 'communeInit');
      }
      fnString += 'if(typeof window === \'undefined\'){\n' + 'self.addEventListener(\'message\', function(e){\n' + '\ncommuneInit.apply(this, e.data);\n});\n}';
      this.blobUrl = makeBlob(fnString);
    }

    Commune.prototype.spawnWorker = function(args, cb) {
      var worker;
      worker = new Worker(this.blobUrl);
      worker.addEventListener('message', function(e) {
        cb(e.data);
        return worker.terminate();
      });
      return worker.postMessage(args);
    };

    return Commune;

  })();

  threadSupport = (function() {
    var BlobBuilder, URL, blobConstructor, rawBlob, sliceMethod, testBlob, testString, testUrl, testWorker;
    blobConstructor = root.BlobBuilder || root.WebKitBlobBuilder || root.MozBlobBuilder || false;
    try {
      testBlob = new Blob;
      BlobBuilder = root.Blob;
    } catch (e) {
      BlobBuilder = blobConstructor;
    }
    URL = root.URL || root.webkitURL || root.mozURL || false;
    if (!(BlobBuilder && URL && root.Worker)) {
      return false;
    }
    testString = 'commune.js';
    try {
      if (BlobBuilder === root.Blob) {
        testBlob = new BlobBuilder([testString]);
        sliceMethod = BlobBuilder.prototype.slice || BlobBuilder.prototype.webkitSlice || BlobBuilder.prototype.mozSlice;
        rawBlob = sliceMethod.call(testBlob);
        makeBlob = function(string) {
          var blob;
          blob = new BlobBuilder([string], {
            type: 'javascript\/javascript'
          });
          return URL.createObjectURL(sliceMethod.call(blob));
        };
      } else {
        testBlob = new BlobBuilder;
        testBlob.append(testString);
        rawBlob = testBlob.getBlob();
        makeBlob = function(string) {
          var blob;
          blob = new BlobBuilder;
          blob.append(string);
          return URL.createObjectURL(blob.getBlob());
        };
      }
      testUrl = URL.createObjectURL(rawBlob);
      testWorker = new Worker(testUrl);
      testWorker.terminate();
      return true;
    } catch (e) {
      if (e.name === 'SECURITY_ERR') {
        if (typeof console !== "undefined" && console !== null) {
          console.warn('Commune: Cannot provision workers when serving' + 'via `file://` protocol. Serve over http to use worker threads.');
        }
      }
      return false;
    }
  })();

  root.commune = function(fn, args, cb) {
    var argList, callback, commune, fnString;
    if (typeof fn !== 'function') {
      throw new Error('Commune: Must pass a function as first argument.');
    }
    if (threadSupport) {
      if (Array.isArray(args)) {
        argList = args;
        if (typeof cb === 'function') {
          callback = cb;
        } else {
          throw new Error('Commune: Must pass a callback to utilize worker result.');
        }
      } else if (typeof args === 'function') {
        callback = args;
        argList = [];
      } else if (args == null) {
        throw new Error('Commune: Must pass a callback to utilize worker result.');
      }
      fnString = fn.toString();
      if (!communes[fnString]) {
        commune = new Commune(fn);
        communes[fnString] = commune;
      } else {
        commune = communes[fnString];
      }
      return commune.spawnWorker(argList, callback);
    } else {
      if (!(args && cb)) {
        return fn();
      }
      if (typeof args === 'function' || !args) {
        cb = args;
        args = [];
      }
      return typeof cb === "function" ? cb(fn(args)) : void 0;
    }
  };

  root.commune.isSupported = threadSupport;

}).call(this);
