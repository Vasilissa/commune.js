// Generated by CoffeeScript 1.3.1

/*
  * Commune.js
  * Web workers lose their chains
  * Easy, DRY, transparent worker threads for your app
  * Dan Motzenbecker
  * MIT License
*/


(function() {
  var Commune, communes, makeBlob, testSupport, threadSupport;

  communes = {};

  makeBlob = null;

  Commune = (function() {

    Commune.name = 'Commune';

    function Commune(fn) {
      var fnName, fnString, lastReturnIndex, returnStatement;
      fnString = fn.toString();
      if (fnString.match(/this/)) {
        (typeof console !== "undefined" && console !== null) && console.warn("Commune: Referencing `this` within a worker process will not work.\n\nThe passed function appears to use it, but the worker will still be created.");
      }
      lastReturnIndex = fnString.lastIndexOf('return');
      if (lastReturnIndex === -1) {
        throw new Error('Commune: Target function has no return statement');
      }
      returnStatement = fnString.substr(lastReturnIndex).replace('return', '').replace(/\}$/, '').replace(';', '');
      fnString = fnString.slice(0, lastReturnIndex) + '\nself.postMessage(' + returnStatement + ');\n}';
      fnName = fnString.match(/function\s(.+)\(/i);
      if (fnName[1] != null) {
        fnString = fnString.replace(fnName[1], 'init');
      }
      fnString = fnString + '\nself.addEventListener(\'message\', function(e){\n' + 'init.apply(this, e.data);\n})';
      this.blobUrl = makeBlob(fnString);
    }

    Commune.prototype.spawnWorker = function(args, cb) {
      var worker;
      worker = new Worker(this.blobUrl);
      worker.addEventListener('message', function(e) {
        cb(e.data);
        return worker.terminate();
      });
      return worker.postMessage(args);
    };

    return Commune;

  })();

  testSupport = function() {
    var BlobBuilder, URL, blobConstructor, rawBlob, sliceMethod, testBlob, testString, testUrl;
    blobConstructor = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || false;
    if (!blobConstructor) {
      return false;
    }
    try {
      testBlob = new Blob;
      BlobBuilder = window.Blob;
    } catch (e) {
      BlobBuilder = blobConstructor;
    }
    URL = window.URL || window.webkitURL || window.mozURL || false;
    if (!URL || !window.Worker) {
      return false;
    }
    testString = 'test';
    try {
      if (BlobBuilder === window.Blob) {
        testBlob = new BlobBuilder([testString]);
        sliceMethod = BlobBuilder.prototype.slice || BlobBuilder.prototype.webkitSlice || BlobBuilder.prototype.mozSlice;
        rawBlob = sliceMethod.call(testBlob);
        makeBlob = function(string) {
          var blob;
          blob = new BlobBuilder([string]);
          return URL.createObjectURL(sliceMethod.call(blob));
        };
      } else {
        testBlob = new BlobBuilder;
        testBlob.append(testString);
        rawBlob = testBlob.getBlob();
        makeBlob = function(string) {
          var blob;
          blob = new BlobBuilder;
          blob.append(string);
          return URL.createObjectURL(blob.getBlob());
        };
      }
      testUrl = URL.createObjectURL(rawBlob);
      return true;
    } catch (e) {
      return false;
    }
  };

  threadSupport = testSupport();

  window.commune = function(fn, args, cb) {
    var argList, callback, commune, fnString, result, self;
    self = window.commune.caller;
    if (!(self != null)) {
      self = window;
    }
    if (typeof fn !== 'function') {
      throw new Error('Commune: Must pass a function as first argument');
    }
    if (threadSupport) {
      if (Array.isArray(args)) {
        argList = args;
        if (typeof cb === 'function') {
          callback = cb;
        } else {
          throw new Error('Commune: Must pass a callback to utilize worker result');
        }
      } else if (typeof args === 'function') {
        callback = args;
        argList = [];
      } else if (!(args != null)) {
        throw new Error('Commune: Must pass a callback to utilize worker result');
      }
      fnString = fn.toString();
      if (!communes[fnString]) {
        commune = new Commune(fn);
        communes[fnString] = commune;
      } else {
        commune = communes[fnString];
      }
      return commune.spawnWorker(argList, callback);
    } else {
      if (!(args != null) && !(cb != null)) {
        return fn.call(self);
      }
      if (typeof args === 'function' || !(args != null)) {
        cb = args;
        args = [];
      }
      result = fn.apply(self, args);
      return cb && cb(result);
    }
  };

}).call(this);
